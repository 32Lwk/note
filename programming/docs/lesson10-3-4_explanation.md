# 課題10-3, 10-4 の詳細解説

## 課題10-3: 台形公式による数値積分

### 何をしているのか

**目的:** 定積分 ∫[0,π] sin(x) dx の値を数値的に計算する

**真値:** ∫[0,π] sin(x) dx = [-cos(x)]₀^π = -cos(π) + cos(0) = 1 + 1 = 2

### 台形公式のアルゴリズム

#### 1. 基本的な考え方

積分区間 [a, b] を n 個の等しい小区間に分割し、各小区間で関数を**直線（1次式）で近似**して面積を計算します。

```
区間 [a, b] を n 分割:
a = x₀ < x₁ < x₂ < ... < xₙ = b

各小区間の幅: h = (b - a) / n
各分割点: xᵢ = a + i·h  (i = 0, 1, 2, ..., n)
```

#### 2. 台形公式の数式

各小区間 [xᵢ, xᵢ₊₁] で、曲線 f(x) を点 (xᵢ, f(xᵢ)) と (xᵢ₊₁, f(xᵢ₊₁)) を結ぶ直線で近似します。

この直線と x 軸で囲まれる**台形の面積**は：
```
Sᵢ = (1/2) · h · [f(xᵢ) + f(xᵢ₊₁)]
```

全小区間の面積を合計すると：
```
∫[a,b] f(x) dx ≈ h · [f(x₀)/2 + f(x₁) + f(x₂) + ... + f(xₙ₋₁) + f(xₙ)/2]
```

#### 3. コードの動作

```c
double trapezoidal(double a, double b, int n) {
    double h = (b - a) / n;  // 小区間の幅を計算
    double sum = 0.5 * (f(a) + f(b));  // 端点の重みは1/2
    
    // 中間点の和を計算（重みは1）
    for (int i = 1; i < n; i++) {
        sum += f(a + i * h);
    }
    
    return h * sum;  // h を掛けて最終的な近似値を返す
}
```

**具体例（n=4の場合）:**
```
区間 [0, π] を4分割:
h = π/4

x₀ = 0,    f(0) = sin(0) = 0
x₁ = π/4,  f(π/4) = sin(π/4) = √2/2 ≈ 0.707
x₂ = π/2,  f(π/2) = sin(π/2) = 1
x₃ = 3π/4, f(3π/4) = sin(3π/4) = √2/2 ≈ 0.707
x₄ = π,    f(π) = sin(π) = 0

近似値 = (π/4) · [0/2 + 0.707 + 1 + 0.707 + 0/2]
       = (π/4) · 2.414
       ≈ 1.896
```

#### 4. 誤差の解析

**誤差の理論式:**
```
誤差 E = -(b-a) · h² · f''(ξ) / 12
```
ここで ξ は区間 [a, b] 内の適当な点です。

**重要なポイント:**
- 誤差は **h² に比例**する（O(h²)）
- h を半分にすると、誤差は **1/4 に減少**する
- これは「2次精度」と呼ばれる

**実行結果からの確認:**
```
N=100:  誤差 = 1.645×10⁻⁴,  h = 3.142×10⁻²
N=200:  誤差 = 4.112×10⁻⁵,  h = 1.571×10⁻²  (hが1/2 → 誤差が約1/4)
N=400:  誤差 = 1.028×10⁻⁵,  h = 7.854×10⁻³  (hが1/2 → 誤差が約1/4)
N=800:  誤差 = 2.570×10⁻⁶,  h = 3.927×10⁻³  (hが1/2 → 誤差が約1/4)

誤差/h² の値:
N=100:  0.1667
N=200:  0.1667
N=400:  0.1667
N=800:  0.1667  (ほぼ一定！)
```

誤差/h² が一定であることから、誤差が O(h²) に従っていることが確認できます。

---

## 課題10-4: シンプソン公式による数値積分

### 何をしているのか

**目的:** 同じく ∫[0,π] sin(x) dx を計算するが、より高精度な方法を使用

**違い:** 台形公式は直線で近似するのに対し、シンプソン公式は**放物線（2次式）で近似**します。

### シンプソン公式のアルゴリズム

#### 1. 基本的な考え方

積分区間 [a, b] を **偶数個**の小区間に分割し、**2つずつの小区間をペア**にして、各ペアで関数を**放物線（2次式）で近似**します。

```
区間 [a, b] を n 分割（nは偶数）:
a = x₀ < x₁ < x₂ < ... < xₙ = b

各小区間の幅: h = (b - a) / n
各分割点: xᵢ = a + i·h  (i = 0, 1, 2, ..., n)

ペア: [x₀, x₂], [x₂, x₄], [x₄, x₆], ...
各ペアで3点 (xᵢ, f(xᵢ)), (xᵢ₊₁, f(xᵢ₊₁)), (xᵢ₊₂, f(xᵢ₊₂)) を通る放物線で近似
```

#### 2. シンプソン公式の数式

各ペア [xᵢ, xᵢ₊₂] で、3点を通る放物線で近似した面積は：
```
Sᵢ = (h/3) · [f(xᵢ) + 4f(xᵢ₊₁) + f(xᵢ₊₂)]
```

全ペアの面積を合計すると：
```
∫[a,b] f(x) dx ≈ (h/3) · [f(x₀) + 4f(x₁) + 2f(x₂) + 4f(x₃) + 2f(x₄) + ... + 4f(xₙ₋₁) + f(xₙ)]
```

**係数のパターン:**
- 端点 (x₀, xₙ): 係数 1
- 奇数インデックス (x₁, x₃, x₅, ...): 係数 4
- 偶数インデックス（端点以外）(x₂, x₄, x₆, ...): 係数 2

#### 3. コードの動作

```c
double simpson(double a, double b, int n) {
    if (n % 2 != 0) {
        n++;  // nは偶数である必要がある
    }
    
    double h = (b - a) / n;
    double sum = f(a) + f(b);  // 端点の係数は1
    
    // 奇数インデックスの項: 係数4
    for (int i = 1; i < n; i += 2) {
        sum += 4.0 * f(a + i * h);
    }
    
    // 偶数インデックス（端点以外）の項: 係数2
    for (int i = 2; i < n; i += 2) {
        sum += 2.0 * f(a + i * h);
    }
    
    return (h / 3.0) * sum;  // h/3 を掛けて最終的な近似値を返す
}
```

**具体例（n=4の場合）:**
```
区間 [0, π] を4分割:
h = π/4

x₀ = 0,    f(0) = 0      (係数1)
x₁ = π/4,  f(π/4) = 0.707  (係数4)
x₂ = π/2,  f(π/2) = 1      (係数2)
x₃ = 3π/4, f(3π/4) = 0.707  (係数4)
x₄ = π,    f(π) = 0        (係数1)

近似値 = (π/4)/3 · [1·0 + 4·0.707 + 2·1 + 4·0.707 + 1·0]
       = (π/12) · [0 + 2.828 + 2 + 2.828 + 0]
       = (π/12) · 7.656
       ≈ 2.004
```

#### 4. 誤差の解析

**誤差の理論式:**
```
誤差 E = -(b-a) · h⁴ · f⁽⁴⁾(ξ) / 180
```
ここで f⁽⁴⁾(ξ) は4階導関数、ξ は区間 [a, b] 内の適当な点です。

**重要なポイント:**
- 誤差は **h⁴ に比例**する（O(h⁴)）
- h を半分にすると、誤差は **1/16 に減少**する
- これは「4次精度」と呼ばれる
- 台形公式（O(h²)）より**はるかに高精度**

**実行結果からの確認:**
```
N=100:  誤差 = 1.082×10⁻⁸,  h = 3.142×10⁻²
N=200:  誤差 = 6.765×10⁻¹⁰, h = 1.571×10⁻²  (hが1/2 → 誤差が約1/16)
N=400:  誤差 = 4.228×10⁻¹¹, h = 7.854×10⁻³  (hが1/2 → 誤差が約1/16)
N=800:  誤差 = 2.641×10⁻¹², h = 3.927×10⁻³  (hが1/2 → 誤差が約1/16)

誤差/h⁴ の値:
N=100:  0.01111
N=200:  0.01111
N=400:  0.01111
N=800:  0.01111  (ほぼ一定！)
```

誤差/h⁴ が一定であることから、誤差が O(h⁴) に従っていることが確認できます。

---

## 台形公式 vs シンプソン公式の比較

### 精度の比較

同じ分割数 N=100 で比較：

| 方法 | 近似値 | 誤差 | 誤差のオーダー |
|------|--------|------|----------------|
| 台形公式 | 1.9998355 | 1.645×10⁻⁴ | O(h²) |
| シンプソン公式 | 2.00000001 | 1.082×10⁻⁸ | O(h⁴) |

**シンプソン公式の誤差は台形公式の約15,000分の1！**

### なぜシンプソン公式の方が高精度なのか？

1. **近似の次数:**
   - 台形公式: 1次式（直線）で近似 → 2次以上の項が誤差
   - シンプソン公式: 2次式（放物線）で近似 → 3次以上の項が誤差

2. **誤差のオーダー:**
   - 台形公式: O(h²) → h を半分にすると誤差が 1/4 に
   - シンプソン公式: O(h⁴) → h を半分にすると誤差が 1/16 に

3. **計算コスト:**
   - どちらも同じ分割数なら、関数の評価回数はほぼ同じ
   - シンプソン公式は係数の計算が少し複雑だが、精度の向上が大きい

### 図解的な理解

**台形公式:**
```
各小区間で:
f(x) ≈ 直線（1次式）
     = f(xᵢ) + (f(xᵢ₊₁) - f(xᵢ))·(x - xᵢ)/h

面積 = 台形の面積
```

**シンプソン公式:**
```
各ペア [xᵢ, xᵢ₊₂] で:
f(x) ≈ 放物線（2次式）
     = 3点 (xᵢ, f(xᵢ)), (xᵢ₊₁, f(xᵢ₊₁)), (xᵢ₊₂, f(xᵢ₊₂)) を通る2次式

面積 = 放物線の下の面積（より正確）
```

---

## まとめ

### 課題10-3（台形公式）
- **目的:** 定積分を数値的に計算
- **方法:** 各小区間で関数を直線で近似
- **精度:** O(h²) - 2次精度
- **特徴:** シンプルで理解しやすい

### 課題10-4（シンプソン公式）
- **目的:** 同じ積分をより高精度で計算
- **方法:** 各ペアの小区間で関数を放物線で近似
- **精度:** O(h⁴) - 4次精度
- **特徴:** 台形公式よりはるかに高精度

両方とも、解析的に積分できない関数や、複雑な積分を数値的に計算する際に非常に有用な手法です。
